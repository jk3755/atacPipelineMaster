peakSites <- genomeSites[peakIndex]
peakSites <- keepStandardChromosomes(peakSites, pruning.mode="coarse")
peakSites <- keepSeqlevels(peakSites, scope, pruning.mode="coarse")
peakSites <- trim(peakSites, use.names = TRUE)
numPeakSites <- length(peakSites)
cat("Found", numPeakSites, " binding sites in peak accessibility regions", "\n")
boundPeakOverlap <- findOverlaps(peakSites, boundGenomeSites)
boundPeakIndex <- unique(boundPeakOverlap@to)
boundPeakSites <- boundGenomeSites[boundPeakIndex]
numBoundPeakSites <- length(boundPeakSites)
##
unboundPeakOverlap <- findOverlaps(peakSites, unboundGenomeSites)
unboundPeakIndex <- unique(unboundPeakOverlap@to)
unboundPeakSites <- unboundGenomeSites[unboundPeakIndex]
numUnboundPeakSites <- length(unboundPeakSites)
## Calculate flanking accessibility and footprint depth data
cat("Calculating flanking accessibility and footprint depth data", "\n")
siteFootprintMetrics <- matrix(data = NA, ncol = 5, nrow = numGenomeSites)
##
colnames(siteFootprintMetrics) <- c("Background signal/bp", "Flank signal/bp", "Motif signal/bp",
"Flanking Accessibility", "Footprint Depth")
##
for (e in 1:numGenomeSites){
## Backgroup signal per bp
siteFootprintMetrics[e,1] <- ((sum(insertionMatrix[e, 1:50]) +
sum(insertionMatrix[e, (450 + motifWidth):(500 + motifWidth)])) /
100)
## Flank signal per bp
siteFootprintMetrics[e,2] <- ((sum(insertionMatrix[e, 200:250]) +
sum(insertionMatrix[e, (200 + motifWidth):(250 + motifWidth)])) /
100)
## Motif signal per bp
siteFootprintMetrics[e,3] <- (sum(insertionMatrix[e, (250:(250 + motifWidth))]) /
motifWidth)
## Flanking accessibility (Flanking signal / backgroun signal)
siteFootprintMetrics[e,4] <- (siteFootprintMetrics[e,2] / siteFootprintMetrics[e,1])
## Footprint depth (Motif signal / flank signal)
siteFootprintMetrics[e,5] <- (siteFootprintMetrics[e,3] / siteFootprintMetrics[e,2])
} # end (for e in 1:numGenomeSites)
View(siteFootprintMetrics)
View(siteFootprintMetrics)
############################################################
## Data transfer to storage object and save
cat("Transferring data to parsedFootprintData storage object", "\n")
tempData <- list()
##
tempData$librarySize <- librarySize
tempData$coverageSize <- coverageSize
tempData$libraryFactor <- libraryFactor
tempData$PWM <- PWM
tempData$genomeSites <- genomeSites
tempData$numGenomeSites <- numGenomeSites
tempData$motifWidth <- motifWidth
tempData$extendedSites <- extendedSites
tempData$insertionMatrix <- insertionMatrix
##
tempData$siteTotalSignal <- siteTotalSignal
tempData$uniqueTotalSiteSignals <- uniqueTotalSiteSignals
tempData$nullModels <- nullModels
tempData$ttest <- ttest
tempData$pvalue <- pvalue
tempData$tvalue <- tvalue
tempData$pvaluePassSiteIdx <- pvaluePassSiteIdx
tempData$bfPvalueSiteIdx <- bfPvalueSiteIdx
##
tempData$boundGenomeSites <- boundGenomeSites
tempData$numBoundGenomeSites <- numBoundGenomeSites
##
tempData$unboundGenomeSites <- unboundGenomeSites
tempData$numUnboundGenomeSites <- numUnboundGenomeSites
##
tempData$peakOverlaps <- peakOverlaps
tempData$peakIndex <- peakIndex
tempData$peakSites <- peakSites
tempData$numPeakSites <- numPeakSites
##
tempData$boundPeakOverlap <- boundPeakOverlap
tempData$boundPeakIndex <- boundPeakIndex
tempData$boundPeakSites <- boundPeakSites
tempData$numBoundPeakSites <- numBoundPeakSites
##
tempData$unboundPeakOverlap <- unboundPeakOverlap
tempData$unboundPeakIndex <- unboundPeakIndex
tempData$unboundPeakSites <- unboundPeakSites
tempData$numUnboundPeakSites <- numUnboundPeakSites
##
tempData$siteFootprintMetrics <- siteFootprintMetrics
## Transfer to the data storage object
com <- paste0("parsedFootprintData$motif", motifIdx, " <- tempData")
eval(parse(text = com))
View(parsedFootprintData)
View(parsedFootprintData)
load("C:/Users/Jordan/Desktop/LNCaP-WT-02.totalreads.Rdata")
cat("Found", sampleTotalReads, "total reads in current sample", "\n")
load("C:/Users/Jordan/Desktop/LNCaP-WT-02.MCR.parsedFootprintData.Rdata")
View(footprintData)
View(footprintData)
####
namePath <- "C:\\Users\\jsk33\\Documents\\git\\atacPipelineMaster\\panTF\\names\\bindingSitesSizeOrdered.txt"
orderedNames <- readLines(namePath)
numGenes <- length(orderedNames)
strings <- c()
a <- 1 # count for genes
b <- 1 # string index (group)
#### Groups 1-40
while (b <= 40){
##
c <- a
d <- a+1
e <- a+2
f <- a+3
g <- a+4
h <- a+5
i <- a+6
j <- a+7
k <- a+8
l <- a+9
m <- a+10
n <- a+11
o <- a+12
p <- a+13
q <- a+14
r <- a+15
s <- a+16
t <- a+17
u <- a+18
v <- a+19
##
tmp1 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[c], ".graphFP.bamcopy1.done", "', ")
tmp2 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[d], ".graphFP.bamcopy2.done", "', ")
tmp3 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[e], ".graphFP.bamcopy3.done", "', ")
tmp4 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[f], ".graphFP.bamcopy4.done", "', ")
tmp5 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[g], ".graphFP.bamcopy5.done", "', ")
tmp6 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[h], ".graphFP.bamcopy6.done", "', ")
tmp7 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[i], ".graphFP.bamcopy7.done", "', ")
tmp8 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[j], ".graphFP.bamcopy8.done", "', ")
tmp9 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[k], ".graphFP.bamcopy9.done", "', ")
tmp10 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[l], ".graphFP.bamcopy10.done", "', ")
tmp11 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[m], ".graphFP.bamcopy11.done", "', ")
tmp12 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[n], ".graphFP.bamcopy12.done", "', ")
tmp13 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[o], ".graphFP.bamcopy13.done", "', ")
tmp14 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[p], ".graphFP.bamcopy14.done", "', ")
tmp15 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[q], ".graphFP.bamcopy15.done", "', ")
tmp16 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[r], ".graphFP.bamcopy16.done", "', ")
tmp17 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[s], ".graphFP.bamcopy17.done", "', ")
tmp18 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[t], ".graphFP.bamcopy18.done", "', ")
tmp19 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[u], ".graphFP.bamcopy19.done", "', ")
tmp20 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[v], ".graphFP.bamcopy20.done", "'")
##
strings[b] <- paste0(
"rule graphFP_group",
b,
":\n",
"\tinput:\n\t\t",
tmp1, "\n\t\t", tmp2, "\n\t\t", tmp3, "\n\t\t", tmp4, "\n\t\t", tmp5, "\n\t\t",
tmp6, "\n\t\t", tmp7, "\n\t\t", tmp8, "\n\t\t", tmp9, "\n\t\t", tmp10, "\n\t\t",
tmp11, "\n\t\t", tmp12, "\n\t\t", tmp13, "\n\t\t", tmp14, "\n\t\t", tmp15, "\n\t\t",
tmp16, "\n\t\t", tmp17, "\n\t\t", tmp18, "\n\t\t", tmp19, "\n\t\t", tmp20, "\n\t",
"output:\n\t\t",
"'{path}footprints/operations/groups/{mergedsample}.graphFP.group", b, ".done'\n",
"\tshell:\n\t\t",
"'touch {output}'")
##
a <- a+20
b <- b+1
}
#### Groups 40-55
while (b <= 55){
##
c <- a
d <- a+1
e <- a+2
f <- a+3
g <- a+4
h <- a+5
i <- a+6
j <- a+7
k <- a+8
l <- a+9
##
tmp1 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[c], ".graphFP.bamcopy1.done", "', ")
tmp2 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[d], ".graphFP.bamcopy2.done", "', ")
tmp3 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[e], ".graphFP.bamcopy3.done", "', ")
tmp4 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[f], ".graphFP.bamcopy4.done", "', ")
tmp5 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[g], ".graphFP.bamcopy5.done", "', ")
tmp6 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[h], ".graphFP.bamcopy6.done", "', ")
tmp7 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[i], ".graphFP.bamcopy7.done", "', ")
tmp8 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[j], ".graphFP.bamcopy8.done", "', ")
tmp9 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[k], ".graphFP.bamcopy9.done", "', ")
tmp10 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[l], ".graphFP.bamcopy10.done", "', ")
##
strings[b] <- paste0(
"rule graphFP_group",
b,
":\n",
"\tinput:\n\t\t",
tmp1, "\n\t\t", tmp2, "\n\t\t", tmp3, "\n\t\t", tmp4, "\n\t\t", tmp5, "\n\t\t",
tmp6, "\n\t\t", tmp7, "\n\t\t", tmp8, "\n\t\t", tmp9, "\n\t\t", tmp10, "\n\t",
"output:\n\t\t",
"'{path}footprints/operations/groups/{mergedsample}.graphFP.group", b, ".done'\n",
"\tshell:\n\t\t",
"'touch {output}'")
##
a <- a+10
b <- b+1
}
## Remaining
while (a <= 1229){
##
c <- a
d <- a+1
e <- a+2
f <- a+3
g <- a+4
##
tmp1 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[c], ".graphFP.bamcopy1.done", "', ")
tmp2 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[d], ".graphFP.bamcopy2.done", "', ")
tmp3 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[e], ".graphFP.bamcopy3.done", "', ")
tmp4 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[f], ".graphFP.bamcopy4.done", "', ")
tmp5 <- paste0("'{path}footprints/operations/graphs/{mergedsample}.", orderedNames[g], ".graphFP.bamcopy5.done", "', ")
##
strings[b] <- paste0(
"rule graphFP_group",
b,
":\n",
"\tinput:\n\t\t",
tmp1, "\n\t\t", tmp2, "\n\t\t", tmp3, "\n\t\t", tmp4, "\n\t\t", tmp5, "\n\t",
"output:\n\t\t",
"'{path}footprints/operations/groups/{mergedsample}.graphFP.group", b, ".done'\n",
"\tshell:\n\t\t",
"'touch {output}'")
##
a <- a+5
b <- b+1
}
#### Write the file ####
outPath <- "C:\\Users\\jsk33\\Documents\\git\\atacPipelineMaster\\panTF\\names\\panTFgraph.snakefile"
##
write.table(
strings,
file = outPath,
quote = FALSE,
sep = ",",
eol = "\n",
row.names = FALSE,
col.names = FALSE)
load("C:/Users/Jordan/Desktop/LNCaP-WT-01.KLF6.rawFootprintData.Rdata")
View(footprintData)
View(footprintData)
suppressMessages(library(GenomicRanges))
suppressMessages(library(stats4))
suppressMessages(library(BiocGenerics))
suppressMessages(library(parallel))
suppressMessages(library(Rsamtools))
suppressMessages(library(GenomicAlignments))
suppressMessages(library(genomation))
suppressMessages(library(seqLogo))
suppressMessages(library(ChIPpeakAnno))
suppressMessages(library(rlist))
suppressMessages(library(TxDb.Hsapiens.UCSC.hg38.knownGene))
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
txdb <- keepStandardChromosomes(txdb, pruning.mode="coarse")
txdb <- trim(txdb)
txdb <- keepStandardChromosomes(txdb, pruning.mode="coarse")
View(footprintData[["motif1"]][["insMatrix"]])
insMatrix <- footprintData[["motif1"]][["insMatrix"]])
insMatrix <- footprintData[["motif1"]][["insMatrix"]]
motifWidth <- 8
#### Generate the insertion site probability vector for raw data
rawInsProb <- c(sum(insMatrix[,1:(500+motifWidth)]))
rawInsProb
#### Generate the insertion site probability vector for raw data
rawInsProb[1:508] <- c(sum(insMatrix[,1:(500+motifWidth)]))
rawInsProb <- c()
for (c in 1:(500 + motifWidth)){
rawInsProb[c] <- sum(insMatrix[,c])
} # end for (c in 1:(500 + motifWidth))
View(rawInsProb)
rawTotalSignal<- sum(rawInsProb)
##
rawInsProb <- rawInsProb / rawTotalSignal
sum(rawInsProb)
#### Set hg38 number of bases (haploid)
hg38TotalBP <- 3272116950
gr <- hg38
seqinfo(hg38)
?seqinfo
library(BSgenome.Hsapiens.UCSC.hg38)
Hsapiens
chr1 <- Hsapiens[["chr1"]]
suppressMessages(library(GenomicRanges))
chr1 <- GRanges(chr1)
genome(gr) <- 'hg38'
Granges(hg38)
GRanges(hg38)
#### Make the hg38 GRanges reference
hg38 <- GRanges(seqinfo(BSgenome.Hsapiens.UCSC.hg38))
hg38 <- keepStandardChromosomes(hg38, pruning.mode="coarse")
hg38 <- trim(hg38)
View(hg38)
View(hg38)
#### Subset hg38 Granges reference to current chromosome
hg38 <- hg38["chr1"]
View(hg38)
View(hg38)
View(hg38)
View(hg38)
load("C:/Users/Jordan/Desktop/LNCaP-WT-01.IVD.rawFootprintData.Rdata")
#### Load libraries
cat("Loading libraries", "\n")
suppressMessages(library(GenomicRanges))
suppressMessages(library(stats4))
suppressMessages(library(BiocGenerics))
suppressMessages(library(parallel))
suppressMessages(library(Rsamtools))
suppressMessages(library(GenomicAlignments))
suppressMessages(library(genomation))
suppressMessages(library(seqLogo))
suppressMessages(library(ChIPpeakAnno))
suppressMessages(library(rlist))
suppressMessages(library(TxDb.Hsapiens.UCSC.hg38.knownGene))
#### Load hg38 annotations
cat("Loading hg38 annotations from TxDb", "\n")
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
txdb <- keepStandardChromosomes(txdb, pruning.mode="coarse")
sampleTotalReads <- 45000000
View(footprintData)
View(footprintData)
tempData <- footprintData[["motif1"]]
PWM <- tempData[["PWM"]]
motifWidth <- tempData[["motifWidth"]]
allSites <- tempData[["allSites"]]
extSites <- tempData[["extSites"]]
insMatrix <- tempData[["insMatrix"]]
libSize <- tempData[["libsize"]]
coverageSize <- tempData[["coverageSize"]]
libFactor <- tempData[["libFactor"]]
## Note that because trimming to standard xsomes is done, will need to set
## the total number of sites to the row number of the insertion matrix here
numSites <- length(insMatrix[,1])
#### Calculate basic statistics for each site with raw data
rawSiteBasicStats <- matrix(data = NA, nrow = numSites, ncol = 10)
colnames(rawSiteBasicStats) <- c("Site index", "Total signal", "Total signal per bp", "Motif signal per bp",
"Flank signal per bp", "Background signal per bp", "Wide flank signal per bp",
"Flank / Background", "Motif / Flank", "Motif / Wide Flank")
#### Populate the basic stats matrix
for (b in 1:numSites){
rawSiteBasicStats[b,1] <- b # Site index
rawSiteBasicStats[b,2] <- sum(insMatrix[b,]) # Total signal
rawSiteBasicStats[b,3] <- rawSiteBasicStats[b,2] / (500 + motifWidth) # Total signal per bp
rawSiteBasicStats[b,4] <- sum(insMatrix[b,(250:(250 + motifWidth))] / motifWidth) # Motif signal per bp
rawSiteBasicStats[b,5] <- (sum(insMatrix[b,200:250]) + sum(insMatrix[b,(250 + motifWidth):(300 + motifWidth)])) / 100 # Flank signal per bp
rawSiteBasicStats[b,6] <- (sum(insMatrix[b,1:50]) + sum(insMatrix[b,(500 + motifWidth-50):(500 + motifWidth)])) / 100 # Background signal per bp
rawSiteBasicStats[b,7] <- (sum(insMatrix[b,1:250]) + sum(insMatrix[b,(250 + motifWidth):(500 + motifWidth)])) / 500 # Wide flank signal per bp
rawSiteBasicStats[b,8] <- rawSiteBasicStats[b,5] / rawSiteBasicStats[b,6] # Flank / background
rawSiteBasicStats[b,9] <- rawSiteBasicStats[b,4] / rawSiteBasicStats[b,5] # Motif / flank
rawSiteBasicStats[b,10] <- rawSiteBasicStats[b,4] / rawSiteBasicStats[b,7] # Motif / wide flank
} # end for (b in 1:numSites)
#### Generate the insertion site probability vector for raw data
rawInsProb <- c()
for (c in 1:(500 + motifWidth)){
rawInsProb[c] <- sum(insMatrix[,c])
} # end for (c in 1:(500 + motifWidth))
rawTotalSignal<- sum(rawInsProb)
rawInsProb <- rawInsProb / rawTotalSignal
#### Make the CPM normalized insertion matrix ####
## This is an important normalization that will allow you to compare one sample to another directly,
## Even if the two samples have a different number of total reads
##
factorCPM <- sampleTotalReads / 1000000
insMatrixNormalizedCPM <- insMatrix / factorCPM
##
#### Calculate basic statistics for each site with raw data
CPMNormalizedSiteBasicStats <- matrix(data = NA, nrow = numSites, ncol = 10)
colnames(CPMNormalizedSiteBasicStats) <- c("Site index", "Total signal", "Total signal per bp", "Motif signal per bp",
"Flank signal per bp", "Background signal per bp", "Wide flank signal per bp",
"Flank / Background", "Motif / Flank", "Motif / Wide Flank")
#### Populate the basic stats matrix
for (b in 1:numSites){
CPMNormalizedSiteBasicStats[b,1] <- b # Site index
CPMNormalizedSiteBasicStats[b,2] <- sum(insMatrixNormalizedCPM[b,]) # Total signal
CPMNormalizedSiteBasicStats[b,3] <- rawSiteBasicStats[b,2] / (500 + motifWidth) # Total signal per bp
CPMNormalizedSiteBasicStats[b,4] <- sum(insMatrixNormalizedCPM[b,(250:(250 + motifWidth))] / motifWidth) # Motif signal per bp
CPMNormalizedSiteBasicStats[b,5] <- (sum(insMatrixNormalizedCPM[b,200:250]) + sum(insMatrixNormalizedCPM[b,(250 + motifWidth):(300 + motifWidth)])) / 100 # Flank signal per bp
CPMNormalizedSiteBasicStats[b,6] <- (sum(insMatrixNormalizedCPM[b,1:50]) + sum(insMatrixNormalizedCPM[b,(500 + motifWidth-50):(500 + motifWidth)])) / 100 # Background signal per bp
CPMNormalizedSiteBasicStats[b,7] <- (sum(insMatrixNormalizedCPM[b,1:250]) + sum(insMatrixNormalizedCPM[b,(250 + motifWidth):(500 + motifWidth)])) / 500 # Wide flank signal per bp
CPMNormalizedSiteBasicStats[b,8] <- CPMNormalizedSiteBasicStats[b,5] / CPMNormalizedSiteBasicStats[b,6] # Flank / background
CPMNormalizedSiteBasicStats[b,9] <- CPMNormalizedSiteBasicStats[b,4] / CPMNormalizedSiteBasicStats[b,5] # Motif / flank
CPMNormalizedSiteBasicStats[b,10] <- CPMNormalizedSiteBasicStats[b,4] / CPMNormalizedSiteBasicStats[b,7] # Motif / wide flank
} # end for (b in 1:numSites)
#### Generate the insertion site probability vector for raw data
CPMNormalizedInsProb <- c()
##
for (c in 1:(500 + motifWidth)){
CPMNormalizedInsProb[c] <- sum(insMatrixNormalizedCPM[,c])
} # end for (c in 1:(500 + motifWidth))
##
CPMNormalizedTotalSignal<- sum(CPMNormalizedInsProb)
CPMNormalizedInsProb <- CPMNormalizedInsProb / CPMNormalizedTotalSignal
View(CPMNormalizedSiteBasicStats)
View(CPMNormalizedSiteBasicStats)
View(rawSiteBasicStats)
View(rawSiteBasicStats)
##
factorCPM <- sampleTotalReads / 1000000
CPMNinsMatrix <- insMatrix / factorCPM
##
#### Calculate basic statistics for each site with raw data
CPMNSiteBasicStats <- matrix(data = NA, nrow = numSites, ncol = 10)
colnames(CPMNSiteBasicStats) <- c("Site index", "Total signal", "Total signal per bp", "Motif signal per bp",
"Flank signal per bp", "Background signal per bp", "Wide flank signal per bp",
"Flank / Background", "Motif / Flank", "Motif / Wide Flank")
#### Populate the basic stats matrix
for (b in 1:numSites){
CPMNSiteBasicStats[b,1] <- b # Site index
CPMNSiteBasicStats[b,2] <- sum(CPMNinsMatrix[b,]) # Total signal
CPMNSiteBasicStats[b,3] <- CPMNSiteBasicStats[b,2] / (500 + motifWidth) # Total signal per bp
CPMNSiteBasicStats[b,4] <- sum(CPMNinsMatrix[b,(250:(250 + motifWidth))] / motifWidth) # Motif signal per bp
CPMNSiteBasicStats[b,5] <- (sum(CPMNinsMatrix[b,200:250]) + sum(CPMNinsMatrix[b,(250 + motifWidth):(300 + motifWidth)])) / 100 # Flank signal per bp
CPMNSiteBasicStats[b,6] <- (sum(CPMNinsMatrix[b,1:50]) + sum(CPMNinsMatrix[b,(500 + motifWidth-50):(500 + motifWidth)])) / 100 # Background signal per bp
CPMNSiteBasicStats[b,7] <- (sum(CPMNinsMatrix[b,1:250]) + sum(CPMNinsMatrix[b,(250 + motifWidth):(500 + motifWidth)])) / 500 # Wide flank signal per bp
CPMNSiteBasicStats[b,8] <- CPMNSiteBasicStats[b,5] / CPMNSiteBasicStats[b,6] # Flank / background
CPMNSiteBasicStats[b,9] <- CPMNSiteBasicStats[b,4] / CPMNSiteBasicStats[b,5] # Motif / flank
CPMNSiteBasicStats[b,10] <- CPMNSiteBasicStats[b,4] / CPMNSiteBasicStats[b,7] # Motif / wide flank
} # end for (b in 1:numSites)
#### Generate the insertion site probability vector for raw data
CPMNInsProb <- c()
##
for (c in 1:(500 + motifWidth)){
CPMNInsProb[c] <- sum(CPMNinsMatrix[,c])
} # end for (c in 1:(500 + motifWidth))
##
CPMNTotalSignal<- sum(CPMNInsProb)
CPMNInsProb <- CPMNInsProb / CPMNTotalSignal
View(CPMNormalizedSiteBasicStats)
View(CPMNormalizedSiteBasicStats)
View(CPMNSiteBasicStats)
View(CPMNSiteBasicStats)
View(rawSiteBasicStats)
View(rawSiteBasicStats)
#### Generate null models, use BF and BH correction to parse ####
## Find the unique values for total signal and generate null models
## Generate null models based on raw signal, correct for CPM after
uniqueTotalSignals <- unique(siteBasicStats[,2])
siteWidth <- 500 + motifWidth
## Initiate a matrix to store the mean null signal in the null model and the input signal to null model
nullModels <- matrix(data = NA, ncol = 2, nrow = length(uniqueTotalSignals))
colnames(nullModels) <- c("Input signal", "Avg motif signal in null model")
CPMNnullModels <- nullModels / factorCPM
generateNullFP <- function(iterations, inputSignal, analysisWidth, motifWidth){
# This script will be used to generate indiviudal null models at predicted motif binding sites across the genome when scanning for TF footprinting from ATAC-seq data. To generate these null models, the current model will need to:
# Consider the total signal (number of insertions) at each specific ~200 bp locus
# Use the actul underlying reference sequence of that ~200 bp stretch from the hg38 reference genome
# Use published or experimentally derived models of Tn5 sequence specific insertion bias
# For each locus, build a probablistic model of insertion site distributions based on the underlying sequence and Tn5 insertion bias
# Generate the null model graph by weighted random residstribution of the total observed signal at that site
# Importantly, the null model must be generated separately for the plus and minus strand, it can then be combined and compared to the combined signal from the reference observed signal at that sequence
# These null models can then be used for a site-by-site comparison of the null model against the observed data to accept or reject the null hypothesis
# iterations = number of iterations
# inputSignals = unique values for total signal
# analysisWidth = total bp in region of interest (flank + background + motif)
# motifWidth = motif width
# declare vector of size n to store average motif signal values
averages <- c()
# generate the null models and calculate motif averages
for (a in 1:iterations){
# declare the null vector
null <- c(1:(analysisWidth))
# randomly distribute the total signal
# size = the number of values to distribute
# prob = probability of each site
# length = length of the generated vector
null <- c(as.vector(rmultinom(1, size=inputSignal, prob=rep(1, length(null)))))
## Calculate the mean signal in motif region
motifStart <- ((analysisWidth - motifWidth)/2)
motifEnd <- (motifStart + motifWidth)
motifAvg <- (sum(null[motifStart:motifEnd])) / motifWidth
## Store the average values
averages[a] <- motifAvg
} # end for (a in 1:n)
return(averages)
} # end generateNullFP function
#### Generate null models, use BF and BH correction to parse ####
## Find the unique values for total signal and generate null models
## Generate null models based on raw signal, correct for CPM after
uniqueTotalSignals <- unique(siteBasicStats[,2])
siteWidth <- 500 + motifWidth
## Initiate a matrix to store the mean null signal in the null model and the input signal to null model
nullModels <- matrix(data = NA, ncol = 2, nrow = length(uniqueTotalSignals))
colnames(nullModels) <- c("Input signal", "Avg motif signal in null model")
CPMNnullModels <- nullModels / factorCPM
## Calculate the null models
for (c in 1:length(uniqueTotalSignals)){
nullVec <- generateNullFP(1000, uniqueTotalSignals[c], siteWidth, motifWidth)
nullModels[c,1] <- uniqueTotalSignals[c]
nullModels[c,2] <- mean(nullVec)
} # end for (c in 1:length(uniqueTotalSignals))
#### Generate null models, use BF and BH correction to parse ####
## Find the unique values for total signal and generate null models
## Generate null models based on raw signal, correct for CPM after
uniqueTotalSignals <- unique(rawSiteBasicStats[,2])
siteWidth <- 500 + motifWidth
## Initiate a matrix to store the mean null signal in the null model and the input signal to null model
nullModels <- matrix(data = NA, ncol = 2, nrow = length(uniqueTotalSignals))
colnames(nullModels) <- c("Input signal", "Avg motif signal in null model")
CPMNnullModels <- nullModels / factorCPM
## Calculate the null models
for (c in 1:length(uniqueTotalSignals)){
nullVec <- generateNullFP(1000, uniqueTotalSignals[c], siteWidth, motifWidth)
nullModels[c,1] <- uniqueTotalSignals[c]
nullModels[c,2] <- mean(nullVec)
} # end for (c in 1:length(uniqueTotalSignals))
