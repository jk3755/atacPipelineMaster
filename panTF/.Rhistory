for (d in 1:numPoints){
Idx <- mrIdx[d]
MRdata[d,1] <- footprintData[Idx,1]
MRdata[d,2] <- cellLine
MRdata[d,3] <- footprintData[Idx,"peak.log2Depth"]
MRdata[d,4] <- footprintData[Idx,"peak.log2Flank"]
MRdata[d,5] <- footprintData[Idx,"RNAexp"]
MRdata[d,6] <- footprintData[Idx,"viperNES"]
MRdata[d,7] <- footprintData[Idx,"promoterPeak.log2Depth"]
MRdata[d,8] <- footprintData[Idx,"promoterPeak.log2Flank"]
MRdata[d,9] <- footprintData[Idx,"bound.log2Depth"]
MRdata[d,10] <- footprintData[Idx,"bound.log2Flank"]
}
#### COAD MR PLOTS ##########################################################################################
### Plot
## All sites, RNA exp
ggplot(MRdata, aes(peak.log2Depth, peak.log2Flank, color = log2(RNAexp))) +
geom_point() +
scale_color_gradient(low="blue", high="red") +
ggtitle(paste0("COAD MR, Depth vs Flank, RNA exp ", cellName)) +
geom_label_repel(aes(label = Gene),
box.padding   = 0.35,
point.padding = 0.5,
segment.color = 'black',
label.size = NA)
ggplot(MRdata, aes(peak.log2Depth, peak.log2Flank, color = viperNES)) +
geom_point() +
scale_color_gradient(low="blue", high="red") +
ggtitle(paste0("COAD MR, Depth vs Flank, VIPER NES ", cellName)) +
geom_label_repel(aes(label = Gene),
box.padding   = 0.35,
point.padding = 0.5,
segment.color = 'black',
label.size = NA)
#### PROMOTERS
ggplot(MRdata, aes(promoterPeak.log2Depth, promoterPeak.log2Flank, color = log2(RNAexp))) +
geom_point() +
scale_color_gradient(low="blue", high="red") +
ggtitle(paste0("Promoters COAD MR, Depth vs Flank, RNA exp ", cellName)) +
geom_label_repel(aes(label = Gene),
box.padding   = 0.35,
point.padding = 0.5,
segment.color = 'black',
label.size = NA)
ggplot(MRdata, aes(promoterPeak.log2Depth, promoterPeak.log2Flank, color = viperNES)) +
geom_point() +
scale_color_gradient(low="blue", high="red") +
ggtitle(paste0("Promoters COAD MR, Depth vs Flank, VIPER NES ", cellName)) +
geom_label_repel(aes(label = Gene),
box.padding   = 0.35,
point.padding = 0.5,
segment.color = 'black',
label.size = NA)
### Bound sites
ggplot(MRdata, aes(bound.log2Depth, bound.log2Flank, color = log2(RNAexp))) +
geom_point() +
scale_color_gradient(low="blue", high="red") +
ggtitle(paste0("Bound COAD MR, Depth vs Flank, RNA exp ", cellName)) +
geom_label_repel(aes(label = Gene),
box.padding   = 0.35,
point.padding = 0.5,
segment.color = 'black',
label.size = NA)
ggplot(MRdata, aes(bound.log2Depth, bound.log2Flank, color = viperNES)) +
geom_point() +
scale_color_gradient(low="blue", high="red") +
ggtitle(paste0("Bound COAD MR, Depth vs Flank, VIPER NES ", cellName)) +
geom_label_repel(aes(label = Gene),
box.padding   = 0.35,
point.padding = 0.5,
segment.color = 'black',
label.size = NA)
load("C:/Users/jsk33/Desktop/H508A-WT-02.NFIL3.rawFootprintData.Rdata")
View(footprintData)
View(footprintData)
## Load libraries
cat("Loading libraries", "\n")
suppressMessages(library(GenomicRanges))
suppressMessages(library(stats4))
suppressMessages(library(BiocGenerics))
suppressMessages(library(parallel))
suppressMessages(library(Rsamtools))
suppressMessages(library(GenomicAlignments))
suppressMessages(library(genomation))
suppressMessages(library(seqLogo))
suppressMessages(library(ChIPpeakAnno))
suppressMessages(library(rlist))
generateNullFP <- function(iterations, inputSignal, analysisWidth, motifWidth){
# This script will be used to generate indiviudal null models at predicted motif binding sites across the genome when scanning for TF footprinting from ATAC-seq data. To generate these null models, the current model will need to:
#- Consider the total signal (number of insertions) at each specific ~200 bp locus
#- Use the actul underlying reference sequence of that ~200 bp stretch from the hg38 reference genome
#- Use published or experimentally derived models of Tn5 sequence specific insertion bias
#- For each locus, build a probablistic model of insertion site distributions based on the underlying sequence and Tn5 insertion bias
#- Generate the null model graph by weighted random residstribution of the total observed signal at that site
#- Importantly, the null model must be generated separately for the plus and minus strand, it can then be combined and compared to the combined signal from the reference observed signal at that sequence
# These null models can then be used for a site-by-site comparison of the null model against the observed data to accept or reject the null hypothesis
# iterations = number of iterations
# inputSignals = unique values for total signal
# analysisWidth = total bp in region of interest (flank + background + motif)
# motifWidth = motif width
##
cat("Generating a null footprint model with the following parameters:", "\n")
cat("Iterations:", iterations, "\n")
cat("Input signal:", inputSignal, "\n")
cat("Analysis window (bp):", analysisWidth, "\n")
cat("Motif width (bp):", motifWidth, "\n")
# declare vector of size n to store average motif signal values
averages <- c()
# generate the null models and calculate motif averages
for (a in 1:iterations){
# declare the null vector
null <- c(1:(analysisWidth))
# randomly distribute the total signal
# size = the number of values to distribute
# prob = probability of each site
# length = length of the generated vector
null <- c(as.vector(rmultinom(1, size = inputSignal, prob = rep(1, length(null)))))
## Calculate the mean signal in motif region
motifStart <- ((analysisWidth - motifWidth) / 2)
motifEnd <- (motifStart + motifWidth)
motifAvg <- (sum(null[motifStart:motifEnd])) / motifWidth
## Store the average values
averages[a] <- motifAvg
} # end for (a in 1:n)
return(averages)
} # end generateNullFP function
plotInsProb <- function(plotTitle = c(""), motifWidth, motifPWM, plotLogo = FALSE, insVector){
## This function uses code adapted from the R package ATACSeqQC
## Plot the figure in a new page in the viewport
grid.newpage()
## Data
totalBP <- length(insVector)
flankBP <- ((totalBP - motifWidth) / 2 ) ## The number of BP flanking the motif on each side
## Plot information
xlab = "Dist. to motif (bp)"
ylab = "Tn5 fragmentation probability"
xlim <- c(0, totalBP + 1)
ylim <- c(0, max(insVector) * 1.12)
## Add the plotting margins to the viewport (sets the outer bounds of the entire image)
vp <- plotViewport(margins=c(5.1, 5.1, 4.1, 2.1), name="plotRegion")
pushViewport(vp)
## Viewport for the graph plotting area
vp1 <- viewport(y=.4, height=.8,
xscale=xlim,
yscale=ylim,
name="footprints")
pushViewport(vp1)
## Add the insertion probability data line
grid.lines(x=1:totalBP,
y=insVector,
default.units="native",
gp=gpar(lwd = 1, col = "darkred")) # lwd = line width, col = line color
## This code adds the x and y axis lines
# at = is a numeric vector with the x-axis locations for tick marks
grid.xaxis(at =
c(seq(1, flankBP, length.out = 3),
flankBP + seq(1, motifWidth),
flankBP + motifWidth + seq(1, flankBP, length.out = 3)),
label = c(-(flankBP + 1 - seq(1, flankBP + 1, length.out = 3)),
rep("", motifWidth),
seq(0, flankBP, len = 3)))
grid.yaxis()
## Adds the dashed line across the x-axis horizontally (motif hashes)
grid.lines(x=c(flankBP, flankBP, 0), y=c(0, max(insVector), ylim[2]),
default.units="native", gp=gpar(lty=2))
##
grid.lines(x=c(flankBP + motifWidth + 1, flankBP + motifWidth + 1, totalBP),
y=c(0, max(insVector), ylim[2]),
default.units="native", gp=gpar(lty=2))
upViewport()
##
vp2 <- viewport(y=.9, height=.2,
xscale=c(0, totalBP + 1),
name="motif")
pushViewport(vp2)
upViewport()
##
legvp <- viewport(x=0.5,
y=0.5,
width=convertX(unit(1, "lines"), unitTo="npc"),
height=convertY(unit(1, "lines"), unitTo="npc"),
just=c("right", "top"), name="legendWraper")
pushViewport(legvp)
upViewport()
##
grid.text(plotTitle,
y=unit(1, "npc")-convertY(unit(1, "lines"), unitTo="npc"),
gp=gpar(cex=1.2, fontface="bold"))
upViewport()
## Add the x and y axis labels to the image
grid.text(xlab, y=unit(1, 'lines'))
grid.text(ylab, x=unit(1, 'line'), rot = 90)
} # end plotInsProb function
## The number of unique motifs for the current gene
numMotif <- length(footprintData)
geneName <- "CDX2"
a <- 6
##
cat("Processing motif", a, "\n")
## will need to improve this code at some point
#tryCatch({
## Prepare the data
cat("Loading data", "\n")
com <- paste0("tempData <- footprintData$motif", a)
eval(parse(text = com))
genomeSites <- tempData[["genomeSites"]]
numSites <- length(tempData[["insMatrix"]][,1])
siteWidth <- length(tempData[["insMatrix"]][1,])
motifWidth <- tempData[["motifWidth"]]
PWM <- footprintData[["motif1"]][["PWM"]][a]
insMatrix <- tempData[["insMatrix"]]
insProfile <- tempData[["rawProfile"]]
insVector <- insProfile[2,]
siteTotalSignal <- c()
## Make graph of the raw peak sites
#svgPath <- paste0(dirPath, "footprints/graphs/peaks/", sampleName, ".", geneName, ".", "motif", a, ".rawpeak.sites.svg")
#svg(file = svgPath)
#cat("Saving peaks footprint image at path:", svgPath, "\n")
#plotTitle <- paste0(sampleName, ".", geneName, ".", "motif", a, ".rawpeaks")
#plotInsProb(plotTitle = plotTitle, motifWidth = motifWidth, motifPWM = PWM, insVector = insVector)
#dev.off()
## Calculate total signal for each site
cat("Calculating total signal at each site", "\n")
##
for (b in 1:numSites){
siteTotalSignal[b] <- sum(tempData[["insMatrix"]][b,])
} # end for (b in 1:numSites)
## Find the unique values for total signal and generate null models
uniqueTotalSignals <- unique(siteTotalSignal)
## Initiate a matrix to store the mean null signal in the null model and the input signal to null model
nullModels <- matrix(data = NA, ncol = 2, nrow = length(uniqueTotalSignals))
colnames(nullModels) <- c("Input signal", "Avg motif signal in null model")
## Calculate the null models
cat("Generating null models", "\n")
for (c in 1:length(uniqueTotalSignals)){
nullVec <- generateNullFP(1000, uniqueTotalSignals[c], siteWidth, motifWidth)
nullModels[c,1] <- uniqueTotalSignals[c]
nullModels[c,2] <- mean(nullVec)} # end for (c in 1:length(uniqueTotalSignals))
## Perform a one-tailed t-test to generate a p-value for each observed motif site
cat("Performing one-tailed t-tests on genome-wide binding sites", "\n")
ttestGenome <- list() # list to store the results of the t-tests
pvalueGenome <- c() # vector to store the p-values
tvalueGenome <- c() # vector to store the t-value
## Perform t-test on all sites
for (d in 1:numSites){
## Retrieve the total signal for the current site
currentSignal <- c(siteTotalSignal[d])
## Retrieve the appropriate null model
currentNullModel <- nullModels[which(nullModels[,1]==currentSignal),2]
## Perform the t-test
ttestGenome[[d]] <- t.test(insMatrix[d,250:(250+motifWidth)], mu=currentNullModel, alternative="less", conf.level = 0.95)
pvalueGenome[d] <- ttestGenome[[d]][["p.value"]]
tvalueGenome[d] <- ttestGenome[[d]][["statistic"]][["t"]]
} # for (d in 1:numSites)
uniqueTotalSignals[c]
View(uniqueTotalSignals)
View(siteTotalSignal)
## Remove NA values from uniqueTotalSignals
## (how do they get there???)
uniqueTotalSignals <- uniqueTotalSignals[!is.na(uniqueTotalSignals)]
View(footprintData)
View(footprintData)
footprintData[["motif6"]][["rawProfile"]]
View(footprintData[["motif6"]][["rawProfile"]])
## Load libraries
cat("Loading libraries...", "\n")
suppressMessages(library(GenomicRanges))
suppressMessages(library(stats4))
suppressMessages(library(BiocGenerics))
suppressMessages(library(parallel))
suppressMessages(library(Rsamtools))
suppressMessages(library(GenomicAlignments))
suppressMessages(library(genomation))
suppressMessages(library(rlist))
load("C:/Users/jsk33/Desktop/bug/NFIL3.bindingSites.Rdata")
numMotif <- length(bindingSites)
##### DEBUGGING #####
bamPath <- "C:\\Users\\jsk33\\Desktop\\bug\\H508A-WT-02-repmerged.bam"
baiPath <- "C:\\Users\\jsk33\\Desktop\\bug\\H508A-WT-02-repmerged.bai"
bamFile <- BamFile(bamPath)
## Initiate an R object to hold all generated data
footprintData <- list()
for (a in 1:numMotif){
com <- paste0("footprintData$motif", a, " <- list()")
eval(parse(text = com))} # end for (a in 1:numMotif)
cat("Analyzing footprints for", geneName, "\n")
cat("Found", numMotif, "unique motifs", "\n")
## Index counter for motif naming, required in case some motifs have no matches in peak sites
idxMotif <- 1
geneName <- "TEST"
## Initiate an R object to hold all generated data
footprintData <- list()
for (a in 1:numMotif){
com <- paste0("footprintData$motif", a, " <- list()")
eval(parse(text = com))} # end for (a in 1:numMotif)
cat("Analyzing footprints for", geneName, "\n")
cat("Found", numMotif, "unique motifs", "\n")
## Index counter for motif naming, required in case some motifs have no matches in peak sites
idxMotif <- 1
b <- 6
##
cat("Analyzing motif", b, "\n")
## Initiate a temporary list object to store data, will be transferred to footprintData list
tempData <- list()
cat("Processing binding sites", "\n")
## Binding Sites
allSites <- bindingSites[[b]][["sites"]]
numSites <- length(allSites)
cat("Found", numSites, "genome-wide binding sites", "\n")
## Transfer the data
tempData$PWM <- bindingSites[[b]][["PWM"]]
tempData$genomeSites <- allSites
tempData$motifWidth <- length(bindingSites[[b]][["PWM"]][1,])
cat("Processing analysis window for each site", "\n")
## extend each range +/- 250 bp from motif edges
tempData$extSites <- promoters(tempData$genomeSites, upstream = 250, downstream = (250 + tempData$motifWidth), use.names=TRUE)
## Read in the data from bam file for current ranges
param <- ScanBamParam(which = tempData$extSites)
## Use GenomicAlignments package to read in bam file to GRanges, also very fast
## Consider each read as a unique element (insertion), not paired end
cat("Loading relevant reads", "\n")
bamIn <- readGAlignments(bamFile, param = param)
##### DEBUGGING #####
bamPath <- "C:\\Users\\jsk33\\Desktop\\bug\\H508A-WT-02-repmerged.bam"
baiPath <- "C:\\Users\\jsk33\\Desktop\\bug\\H508A-WT-02-repmerged.bai"
geneName <- "TEST"
b <- 6
load("C:/Users/jsk33/Desktop/bug/NFIL3.bindingSites.Rdata")
numMotif <- length(bindingSites)
bamFile <- BamFile(bamPath)
## Initiate an R object to hold all generated data
footprintData <- list()
## Initiate an R object to hold all generated data
footprintData <- list()
for (a in 1:numMotif){
com <- paste0("footprintData$motif", a, " <- list()")
eval(parse(text = com))} # end for (a in 1:numMotif)
cat("Analyzing footprints for", geneName, "\n")
cat("Found", numMotif, "unique motifs", "\n")
## Index counter for motif naming, required in case some motifs have no matches in peak sites
idxMotif <- 1
##
cat("Analyzing motif", b, "\n")
## Initiate a temporary list object to store data, will be transferred to footprintData list
tempData <- list()
cat("Processing binding sites", "\n")
## Binding Sites
allSites <- bindingSites[[b]][["sites"]]
## Trim the matched binding sites to the standard chromosomes only
scope <- paste0("chr", c(1:22, "X", "Y"))
allSites <- keepStandardChromosomes(allSites, pruning.mode="coarse")
allSites <- keepSeqlevels(allSites, scope, pruning.mode="coarse")
##
numSites <- length(allSites)
cat("Found", numSites, "genome-wide binding sites", "\n")
## Transfer the data
tempData$PWM <- bindingSites[[b]][["PWM"]]
tempData$genomeSites <- allSites
tempData$motifWidth <- length(bindingSites[[b]][["PWM"]][1,])
cat("Processing analysis window for each site", "\n")
## extend each range +/- 250 bp from motif edges
tempData$extSites <- promoters(tempData$genomeSites, upstream = 250, downstream = (250 + tempData$motifWidth), use.names=TRUE)
## Read in the data from bam file for current ranges
param <- ScanBamParam(which = tempData$extSites)
## Use GenomicAlignments package to read in bam file to GRanges, also very fast
## Consider each read as a unique element (insertion), not paired end
cat("Loading relevant reads", "\n")
bamIn <- readGAlignments(bamFile, param = param)
## Convert GAlignments to GRanges
cat("Converting reads to insertions", "\n")
grIn <- granges(bamIn)
## Trim everything but standard chromosomes, trim out of bounds ranges
grIn <- keepStandardChromosomes(grIn, pruning.mode="coarse")
grIn <- trim(grIn)
## Convert the reads to insertions with width = 1
grIn2 <- resize(grIn, width = 1)
## Subset the Granges object into plus and minus strands for shifting
cat("Shifting insertions +4/-5 bp", "\n")
plusIdx <- which(strand(grIn2) == "+")
minusIdx <- which(strand(grIn2) == "-")
grPlus <- grIn2[plusIdx]
grMinus <- grIn2[minusIdx]
## Shift the ATACseq reads to account for Tn5 insertion mechanism
## shift end of fragment +4 bp (plus strand) or -5 bp (minus standed)
grPlusShifted <- shift(grPlus, shift=4L)
grMinusShifted <- shift(grMinus, shift=-5L)
## Merge the plus and minus strand shifted Granges
grMerged <- c(grPlusShifted, grMinusShifted)
tempData$shiftedInsertions <- grMerged
## Perform the footprint calculations
## Convert Tn5 insertions corrected Granges to Rle object
cat("Generating insertion matrix", "\n")
insRLE <- coverage(grMerged)
## Get the matching sites
extSites <- tempData$extSites
extSites <- keepStandardChromosomes(extSites, pruning.mode="coarse")
extSites <- trim(extSites)
## Create a views object for the Rle list using the Granges sites data
insViews <- Views(insRLE, extSites)
## Convert to a matrix
insMatrix <- as.matrix(insViews)
## Calculate the insertion probability at each basepair
cat("Calculating insertion probabilies", "\n")
rawTotalSignal <- sum(insMatrix)
rawProfile <- matrix(data = NA, ncol = length(insMatrix[1,]), nrow = 2)
rownames(rawProfile) <- c("Column sums", "Insertion frequency")
##
for (c in 1:length(insMatrix[1,])){
rawProfile[1,c] <- sum(insMatrix[,c])
rawProfile[2,c] <- (rawProfile[1,c] / rawTotalSignal) * 100
} # end for (c in 1:length(insMatrix[1,]))
## Store the data
cat("Storing data", "\n")
tempData$extSites <- extSites
tempData$insRLE <- insRLE
tempData$insViews <- insViews
tempData$insMatrix <- insMatrix
tempData$rawTotalSignal <- rawTotalSignal
tempData$rawProfile <- rawProfile
tempData$libSize <- length(bamIn)
tempData$coverageSize <- sum(as.numeric(width(reduce(grIn, ignore.strand=TRUE))))
tempData$libFactor <- tempData$libSize / tempData$coverageSize
## Calculate flanking accessibility and footprint depth data
cat("Calculating flanking accessibility and footprint depth data", "\n")
rawFootprintMetrics <- matrix(data = NA, ncol = 5, nrow = length(tempData$insMatrix[,1]))
colnames(rawFootprintMetrics) <- c("Background", "Flanking", "Motif", "Flanking Accessibility", "Footprint Depth")
for (d in 1:length(tempData$insMatrix[,1])){
rawFootprintMetrics[d,1] <- (sum(tempData$insMatrix[d,1:50]) + sum(tempData$insMatrix[d,(450 + tempData$motifWidth):(500 + tempData$motifWidth)]))
rawFootprintMetrics[d,2] <- (sum(tempData$insMatrix[d,200:250]) + sum(tempData$insMatrix[d,(200 + tempData$motifWidth):(250 + tempData$motifWidth)]))
rawFootprintMetrics[d,3] <- sum(tempData$insMatrix[d,(250:(250 + tempData$motifWidth))])
rawFootprintMetrics[d,4] <- rawFootprintMetrics[d,2] / rawFootprintMetrics[d,1]
rawFootprintMetrics[d,5] <- rawFootprintMetrics[d,3] / rawFootprintMetrics[d,2]
} # end (for d in 1:length(tempData$insMatrix[,1]))
##
tempData$rawFootprintMetrics <- rawFootprintMetrics
#### Transfer all the data for the current motif to the storage object
cat("Transferring all data to storage object footprintData", "\n")
com <- paste0("footprintData$motif", idxMotif, " <- tempData")
eval(parse(text = com))
} # end for (b in 1:numMotif)
View(insRLE)
View(insRLE)
View(extSites)
View(extSites)
extSites@seqnames@values
View(grMerged)
View(grMerged)
grMerged@seqnames@values
View(insRLE)
View(insRLE)
?coverage
View(insRLE)
View(insRLE)
View(insRLE)
View(insRLE)
names(insRLE@listData)
which(names(insRLE@listData) != "chrM")
insRLE@listData <- insRLE@listData[which(names(insRLE@listData) != "chrM")]
View(insRLE)
View(insRLE)
## Convert to a matrix
insMatrix <- as.matrix(insViews)
## Calculate the insertion probability at each basepair
cat("Calculating insertion probabilies", "\n")
rawTotalSignal <- sum(insMatrix)
rawProfile <- matrix(data = NA, ncol = length(insMatrix[1,]), nrow = 2)
rownames(rawProfile) <- c("Column sums", "Insertion frequency")
cat("Generating insertion matrix", "\n")
insRLE <- coverage(grMerged)
## Get rid of the mitochondrial data
insRLE@listData <- insRLE@listData[which(names(insRLE@listData) != "chrM")]
## Get the matching sites
extSites <- tempData$extSites
extSites <- keepStandardChromosomes(extSites, pruning.mode="coarse")
extSites <- trim(extSites)
## Create a views object for the Rle list using the Granges sites data
insViews <- Views(insRLE, extSites)
## Calculate the insertion probability at each basepair
cat("Calculating insertion probabilies", "\n")
rawTotalSignal <- sum(insMatrix)
rawProfile <- matrix(data = NA, ncol = length(insMatrix[1,]), nrow = 2)
rownames(rawProfile) <- c("Column sums", "Insertion frequency")
##
for (c in 1:length(insMatrix[1,])){
rawProfile[1,c] <- sum(insMatrix[,c])
rawProfile[2,c] <- (rawProfile[1,c] / rawTotalSignal) * 100
} # end for (c in 1:length(insMatrix[1,]))
## Store the data
cat("Storing data", "\n")
tempData$extSites <- extSites
tempData$insRLE <- insRLE
tempData$insViews <- insViews
tempData$insMatrix <- insMatrix
tempData$rawTotalSignal <- rawTotalSignal
tempData$rawProfile <- rawProfile
tempData$libSize <- length(bamIn)
tempData$coverageSize <- sum(as.numeric(width(reduce(grIn, ignore.strand=TRUE))))
tempData$libFactor <- tempData$libSize / tempData$coverageSize
## Convert to a matrix
insMatrix <- as.matrix(insViews)
## Calculate the insertion probability at each basepair
cat("Calculating insertion probabilies", "\n")
rawTotalSignal <- sum(insMatrix)
rawProfile <- matrix(data = NA, ncol = length(insMatrix[1,]), nrow = 2)
rownames(rawProfile) <- c("Column sums", "Insertion frequency")
##
for (c in 1:length(insMatrix[1,])){
rawProfile[1,c] <- sum(insMatrix[,c])
rawProfile[2,c] <- (rawProfile[1,c] / rawTotalSignal) * 100
} # end for (c in 1:length(insMatrix[1,]))
View(rawProfile)
View(rawProfile)
